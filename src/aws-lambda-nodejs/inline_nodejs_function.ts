/* eslint @typescript-eslint/no-require-imports: "off" */
/* eslint import/no-extraneous-dependencies: "off" */
/* eslint no-bitwise: "off" */

import crypto = require('crypto')
import fs = require('fs');
import { FileSystem, IInspectable, TreeInspector } from 'aws-cdk-lib';
import { Code, Function, FunctionOptions, Runtime } from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';
import { NAMESPACE } from '../core/private/internals';

/**
 * Trims lines from inline JS
 *
 * @param code
 */
function trimLines(code: string) {
  return code.split('\n').map(x => x.trim()).join('\n');
}

/**
 * Strips comments from inline JS
 * @param code
 */
function stripComments(code: string) {
  return code.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '').trim();
}

/**
 * Returns a new directory under tmp folder.
 */
const minifiedOutDir = (function () {
  let _minifiedOutDir: string | undefined = undefined;
  return function () {
    if (!_minifiedOutDir) {
      _minifiedOutDir = FileSystem.mkdtemp('minified-');
    }
    return _minifiedOutDir;
  };
})();

/**
 * Returns a minified version of the javascript generated by the lambdas.
 *
 * This allows one to keep the lambda typescript code readable, and still deploy it
 * as inline-code.
 *
 * Uses simple minification.
 *
 * @param constructPath Path to construct (construct.node.path).
 * @param entry Javascript file path.
 * @param minifyEngine Which minification engine to use.
 */
function getInlineCode(constructPath: string, entry: string, minifyEngine: MinifyEngine): string {
  let inlineCode: string | undefined;

  if (!inlineCode && minifyEngine == MinifyEngine.ES_BUILD) {
    inlineCode = getInlineCodeEsBuild(constructPath, entry);
  }
  if (!inlineCode && minifyEngine == MinifyEngine.SIMPLE) {
    inlineCode = getSimpleMinification(constructPath, entry);
  }

  if (!inlineCode) {
    inlineCode = fs.readFileSync(entry, { encoding: 'utf-8' });
  }

  return inlineCode;
}

/**
 * Returns the minified code temporary file for the construct.
 * @param constructPath Path to construct (construct.node.path).
 * @param entry Javascript file path.
 */
function getMinifiedTmpFile(constructPath: string, entry: string) {
  let fileName = function (str: string) {
    return str.split('\\').pop()!.split('/').pop()!;
  }(entry);
  // Good enough for git, good enough here.
  let hash = crypto
    .createHash('sha1')
    .update(constructPath)
    .digest('hex')
    .substring(0, 8);

  return `${minifiedOutDir()}/${hash}-${fileName}`;
}

/**
 * Trims whitespace and removes comments.
 * @param constructPath Path to construct (construct.node.path).
 * @param entry Javascript file path.
 */
function getSimpleMinification(constructPath: string, entry: string) {
  let code = trimLines(stripComments(fs.readFileSync(entry, { encoding: 'utf-8' })));

  // Write the minified code to a tmp file so the user can copy it into the console easily.
  let tmpFile = getMinifiedTmpFile(constructPath, entry);
  fs.writeFileSync(tmpFile, code, { encoding: 'utf-8' });

  return code;
}

/**
 * EsBuild minifier.
 * @param constructPath Path to construct (construct.node.path).
 * @param entry Javascript file path.
 * @returns Minified code.
 */
function getInlineCodeEsBuild(constructPath: string, entry: string) {
  let esBuild: any;
  try {
    esBuild = require('esbuild');
  } catch (e) {
    throw new Error('esbuild must be installed to use Minification.ES_BUILD (the default).  ' +
    'Add esbuild to your package.json file or switch your InlineNodejsFunction to ' +
    'MinifyEngine.SIMPLE or MinifyEngine.NONE');
  }
  let code = esBuild.transformSync(fs.readFileSync(entry, { encoding: 'utf-8' }), {
    minify: true,
  }).code;

  // Write the minified code to a tmp file so the user can copy it into the console easily.
  let tmpFile = getMinifiedTmpFile(constructPath, entry);
  fs.writeFileSync(tmpFile, code, { encoding: 'utf-8' });

  return code as string;
}

/**
 * Minification engine enum.
 */
export enum MinifyEngine {
  /** No minification. */
  NONE = 0,
  /**
   * Uses esbuild for minification.
   * Add the following to your package.json file:
   * ```
   * "esbuild": "^0.18.6"
   * ```
   */
  ES_BUILD = 1,
  /**
   * Removes comments and trims leading/trailing spaces from lines.
   */
  SIMPLE = 2
}

/**
 * Properties for a inline NodejsFunction.
 */
export interface InlineNodejsFunctionProps extends FunctionOptions {
  /**
   * Path to the entry file (JavaScript only).
   *
   * If you are using typescript, just pass the path to the compiled .js file.
   */
  readonly entry?: string;

  /**
   * The name of the exported handler in the entry file.
   *
   * @default index.handler
   */
  readonly handler?: string;

  /**
   * The runtime environment. Only runtimes of the Node.js family are
   * supported.
   *
   * @default Runtime.NODEJS_18_X
   */
  readonly runtime?: Runtime;

  /**
    * Default is "SIMPLE".  See {@link MinifyEngine} for values.
    */
  readonly minifyEngine?: MinifyEngine;
}

/**
 * Inline code version of NodejsFunction.  Write Lambda code in the CDK package,
 * in either JavaScript or TypeScript.
 *
 * Creates a Lambda from a single JavaScript file included in your package.
 * This file is passed to InlineNodejsFunction via {@link InlineNodejsFunctionProps.entry}.
 * It does not compile TypeScript, as the original TypeScript files will not be
 * included in your package (by default), while the compiled JavaScript will be.
 *
 * Inline Lambda runs only with the code in the .js entry file provided and the
 * AWS Lambda NodeJS runtime.  Thus while the entry file can export functions and
 * types to the rest of your CDK package, it cannot import anything
 * not available in the Lambda runtime.  The Lambda runtime includes the base Node library,
 * along with aws-sdk and/or @aws-sdk.  If you require any additional
 * bundling, use NodejsFunction, which supports the full suite of esbuild options.
 *
 * This class minifies your JavaScript code, so you can feel free to add comments
 * and proper variables names in your inline code.  They will be stripped away,
 * depending on which minification engine you use (See {@link MinifyEngine}).
 *
 * This class writes out the minified javascript code to
 * `${process.env.TMPDIR}/minified-${RANDOM_CHARS}/${OTHER_RANDOM_CHARS}-<entryfile>.js`.
 * This allows the user to find the file and copy updated JavaScript right to the AWS lambda console.
 * It reduces your turn around time when coding a new lambda.
 *
 * It's amazing how much can be accomplished using small, inline TypeScript Lambdas.
 * Typical use cases:  StepFunction lambdas.  Provider-based Custom Resource handlers.
 *
 * Code size is limited by AWS Lambda to 4096 characters.
 *
 * InlineNodejsFunction.tmpFileName contains the path of the temporary file with the
 * minified code.  This path is also published to tree.json via IInspectiable.
 * This enables quick development turn around by
 * copying the minified code to the Lambda console.
 */
export class InlineNodejsFunction extends Function implements IInspectable {
  /** Link in tree.json to the file used for inline code. */
  static readonly TMP_FILE_ATTRIBUTE_NAME = `${NAMESPACE}.InlineNodejsFunction.tmpfile`;

  static minifyEngineFromProps(props: InlineNodejsFunctionProps) {
    return (props.minifyEngine == undefined) ? MinifyEngine.SIMPLE : props.minifyEngine;
  }

  /**
   * Path to the temporary file with the minified code.
   * This path is also published via IInspectiable, and thus will appear in
   * the tree.json file as attribute "@open-constructs/aws-cdk.InlineNodejsFunction.tmpfile".
   *
   * This makes it possible to get quick development turn around by
   * compiling your project and copying the minified code to the console.
   * Note the location will change for each compile, so re-query the tree.json file.
   */
  readonly tmpFile: string;

  constructor(scope: Construct, id: string,
    private readonly props: InlineNodejsFunctionProps) {
    super(scope, id, {
      ...props as FunctionOptions,
      code: Code.fromInline(getInlineCode(scope.node.path + '/' + id, props.entry!,
        InlineNodejsFunction.minifyEngineFromProps(props))),
      runtime: props.runtime ?? Runtime.NODEJS_18_X,
      handler: props.handler ?? 'index.handler',
    });

    this.tmpFile = getMinifiedTmpFile(scope.node.path + '/' + id, this.props.entry!);
  }

  inspect(inspector: TreeInspector): void {
    inspector.addAttribute(InlineNodejsFunction.TMP_FILE_ATTRIBUTE_NAME, this.tmpFile);
  }
}
